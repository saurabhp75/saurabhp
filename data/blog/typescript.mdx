---
title: 'Typescript'
date: '2019-10-11'
tags: ['Typescript']
draft: false
summary: 'Introduction to Typescript'
---

## Introduction

- Superset of JS.
- Add static type to JS.
- We can use type annotations on variables for eg, `let myAge: number;`
- In the output `js` file, the types are removed/erased.
- Type annotations never change the runtime behavior of your program.
- `noImplicitAny`: When true, ts will issue an error whenever it would have inferred `any`.
- `strictNullChecks`: When true, `null` and `undefined` have their own distinct types and you’ll get a type error if you try to use them where a concrete value is expected.

## Downlevelling

- The process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is called `downleveling`.

## Running a ts file

- Install typescript `npm install -g typescript`.
- `npx tsc filename.ts`: If you’d prefer to run tsc from a local `node_modules` package instead.
- `tsc filename.ts`: If you want to tsc from global installation.

## Type vs interface

- You should prefer `interface`. Use `type` when you need specific features.

- Primitive types: number, string and boolean.

## Complex types: arrays and objects

- For eg. `number[]`, `string[]`, boolean[] etc. Alternatively `Array<number>`, `Array<string>`, `Array<boolean>`.
- Represented as `T<U>` using generics.

## Any type

- Special ts type, you can use whenever you don’t want a particular value to cause typechecking errors.
- You can access any properties of it (which will in turn be of type any), call it like a function, assign it to (or from) a value of any type, or pretty much anything else that’s syntactically legal.
- It is assumed you know the environment better than TypeScript.
- When you don’t specify a type, and ts can’t infer it from context, the compiler will typically default to `any`.
- You usually want to avoid this, though, because `any` isn’t type-checked. Use the compiler flag `noImplicitAny` to flag any "implicit" `any` as an error.

```javascript
let person: {
  name: string,
  age: number,
}
```

## TS and functions

- When a parameter has a type annotation, arguments to that function will be checked.
- Even if there is no annotations on parameters, ts will still check if the right number of arguments were passed.

## Anonymous functions

- When a function appears in a place where ts can determine how it’s going to be called, the parameters of that function are automatically given types.
- This process is called `contextual typing` because the context that the function occurred within informs what type it should have.

```javascript
// No type annotations here, but TypeScript can spot the bug
const names = ['Alice', 'Bob', 'Eve']

// Contextual typing also applies to arrow functions
names.forEach((s) => {
  console.log(s.toUppercase())
  // Property 'toUppercase' does not exist on type 'string'.
  // Did you mean 'toUpperCase'?
})
```

## Object Types

- This refers to any JavaScript value with properties, which is almost all of them! To define an object type, we simply list its properties and their types.
- The type part of each property is also optional. If you don’t specify a type, it will be assumed to be any.
- Object types can also specify that some or all of their properties are optional. To do this, add a `?` after the property name.

```javascript
// The parameter's type annotation is an object type
// You can use , or ; to separate the properties,
// and the last separator is optional either way.
function printCoord(pt: { x: number, y: number }) {
  console.log("The coordinate's x value is " + pt.x)
  console.log("The coordinate's y value is " + pt.y)
}
printCoord({ x: 3, y: 7 })
```

## Accessing properties in javascript

- In JavaScript, if you access a property that doesn’t exist, you’ll get the value `undefined` rather than a runtime error.
- Because of this, when you read from an optional property, you’ll have to check for `undefined` before using it.
- A safe alternative is using modern JavaScript syntax, `?`.

## Union Types

- TypeScript’s type system allows you to build new types out of existing ones using a large variety of `operators`.
- A union type is a type formed from two or more other types, representing values that may be any one of those types.
- We refer to each of these types as the union’s `members`.

## Working with union types

- Ts will only allow an operation if it is valid for every member of the union. For example, if you have the union `string | number`, you can’t use methods that are only available on string.
- The solution is to `narrow` the union with code by using `if` checks.

## Finding the types of a variable

- For primitive types, we use `typeof` operator to find it's type.
- For arrays, we use `Array.isArray(x)`.

## Type Aliases

- When we want to use `object` and `union` types more than once it is convinient to use type aliases.
- Type alises are name for any type.

```javascript
type Point = {
  x: number,
  y: number,
}

type ID = number | string

interface Point {
  x: number;
  y: number;
}
```

## Interfaces

- An `interface declaration` is another way to name an object type.

- One such operator is `union` (`|`).

- Array of object type.

- Type inference in ts.

- Using union types in ts. Use |.

## Type aliases

```javascript
type person = {
  name: string,
  age: number,
}
```

## Differences Between Type Aliases and Interfaces

- Key distinction is that a `type` cannot be re-opened to add new properties vs an `interface` which is always extendable.
- If you would like a heuristic, use interface until you need to use features from type.

## Extending an interface

```javascript
interface Animal {
  name: string;
}

interface Bear extends Animal {
  honey: boolean;
}

// getBear() gives Bear type
const bear = getBear()
bear.name
bear.honey
```

## extending a type via intersections

```javascript
type Animal = {
  name: string,
}

type Bear = Animal & {
  honey: boolean,
}

// getBear() gives Bear type
const bear = getBear()
bear.name
bear.honey
```

## Adding new fields to an existing interface

```javascript
interface Window {
  title: string;
}

interface Window {
  ts: TypeScriptAPI;
}

const src = 'const a = "Hello World"'
window.ts.transpileModule(src, {})
```

## A type cannot be changed after being created

```javascript
type Window = {
  title: string,
}

type Window = {
  ts: TypeScriptAPI,
}

// Error: Duplicate identifier 'Window'.
```

## Type Assertions

- Sometimes you will have information about the type of a value that TypeScript can’t know about.
- Like a type annotation, type assertions are removed by the compiler and won’t affect the runtime behavior of your code.
- Ts only allows type assertions which convert to a more specific or less specific version of a type. This rule prevents “impossible” coercions like.
- `const x = "hello" as number;`
- Sometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to any (or unknown), then to the desired type: `const a = (expr as any) as T;`

```javascript
// Ts knows that this will return some kind of HTMLElement,
// but you know that your page will always have an
// HTMLCanvasElement with a given ID
const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;

// You can also use the angle-bracket syntax
// (except if the code is in a .tsx file)
const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas");
```

## Literal Types

- In addition to the general types `string` and `number`, we can refer to specific strings and numbers in type positions.
- But by combining literals into unions, you can express a much more useful concept - for eg, functions that only accept a certain set of known values.
- You can combine these with non-literal types.
- `boolean literals`: There are only two boolean literal types, `true` and `false`. The type boolean itself is actually just an alias for the union `true | false`.

```javascript
function printText(s: string, alignment: 'left' | 'right' | 'center') {
  // ...
}

function compare(a: string, b: string): -1 | 0 | 1 {
  return a === b ? 0 : a > b ? 1 : -1
}

interface Options {
  width: number;
}

function configure(x: Options | 'auto') {
  // ...
}
```

## Literal inference

```javascript
// Argument of type 'string' is not assignable to parameter
// of type '"GET" | "POST"'.
const req = { url: "https://example.com", method: "GET" };
handleRequest(req.url, req.method);

// Solution 1:
const req = { url: "https://example.com", method: "GET" as "GET" };
// Solution 2
handleRequest(req.url, req.method as "GET");
// Solution 3:
const req = { url: "https://example.com", method: "GET" } as const
```

## null and undefined

- `strictNullChecks off`: Values that might be null or undefined can still be accessed normally, and the values null and undefined can be assigned to a property of any type. This setting is not recommended as it is major source of bugs.
- `strictNullChecks on`: When a value is null or undefined, you will need to test for those values before using methods or properties on that value.
- Use `!` when you know that the value can’t be null or undefined.

## Non-null Assertion Operator (Postfix !)

- Writing `!` after any expression is effectively a type assertion that the value isn’t `null` or `undefined`.
- It is used for removing `null` and `undefined` from a type without doing any explicit checking.

## Enums

- Not used often.

# Less Common Primitives

## bigint

- From ES2020 onwards, there is a primitive in JavaScript used for very large integers, `BigInt`.

```javascript
// Creating a bigint via the BigInt function
const oneHundred: bigint = BigInt(100)

// Creating a BigInt via the literal syntax
const anotherHundred: bigint = 100n
```

## symbol

- primitive in JavaScript used to create a `globally unique reference` via the function `Symbol()`.

```javascript
const firstName = Symbol('name')
const secondName = Symbol('name')

if (firstName === secondName) {
  // This condition will always return 'false'
  // since the types 'typeof firstName' and
  // 'typeof secondName' have no overlap.
  // Can't ever happen
}
```

# Narrowing

- `Type guard`: Special checks in the code that helps ts to narrow down the types to more specific type than declared.
- `Narrowing`: It is the process of refining types to more specific types than declared.

## Different constructs TypeScript understands for narrowing

- `typeof` typegaurd.
- Truthiness narrowing.
- Equality narrowing.
- The `in` operator narrowing.
- `instanceof` narrowing.
- Assignments.

## `typeof` typegaurd

- In TypeScript, checking against the value returned by `typeof` is a type guard. `typeof` operator returns following strings. Notice that `typeof` doesn’t return the string `null`. In JS arrays are `objects` and `typeof` `null` is `object`.
  - `string`
  - `number`
  - `bigint`
  - `boolean`
  - `symbol`
  - `undefined`
  - `object`
  - `function`

## Truthiness narrowing

- In JS, we can use any expression in conditionals, `&&`, `||`, `if` statements, Boolean negations (`!`), and more. As an example, `if` statements don’t expect their condition to always have the type `boolean`.

- In JS, conditionals first `coerce` their conditionals to `boolean` to make sense of them and then chose their branches depending on whether the result is `true or `false`. Following values are coerced to `false`.
  - `0`
  - `NaN`
  - `""` (the empty string)
  - `0n (the bigint version of zero)`
  - `null`
  - `undefined`

```javascript
// both of these result in 'true'
Boolean('hello') // type: boolean, value: true
!!'world' // type: true, value: true

function printAll(strs: string | string[] | null) {
  // null and array type removed in this conditional
  if (strs && typeof strs === 'object') {
    for (const s of strs) {
      console.log(s)
    }
  } else if (typeof strs === 'string') {
    console.log(strs)
  }
}
```

## Equality narrowing

- Ts uses `switch` statements and equality checks like `===`, `!==`, `==`, and `!=` to narrow types.

- Lose checking (`==`,`!=`): Whether something `== null` actually not only checks whether it is specifically the value `null`, it also checks whether it’s potentially `undefined`. The same applies to `== undefined`, it checks whether a value is either `null` or `undefined`.

```javascript
function example(x: string | number, y: string | boolean) {
  if (x === y) {
    // We can now call any 'string' method on 'x' or 'y'.
    // (method) String.toUpperCase(): string
    x.toUpperCase()

    // (method) String.toLowerCase(): string
    y.toLowerCase()
  } else {
    // (parameter) x: string | number
    console.log(x)

    // (parameter) y: string | boolean
    console.log(y)
  }
}
```

## The `in` operator narrowing

- Ts takes `in` operator into account as a way to narrow down potential types

```JavaScript
type Fish = { swim: () => void };
type Bird = { fly: () => void };
type Human = { swim?: () => void; fly?: () => void };

function move(animal: Fish | Bird | Human) {
  // Notice that "human" type show up in
  // both sides of the "in" check
  if ("swim" in animal) {
  // (parameter) animal: Fish | Human
    animal;
  } else {
   // (parameter) animal: Bird | Human
    animal;
  }
}
```

## `instanceof` narrowing

- In JS `x instanceof Foo` checks whether the `prototype chain` of `x` contains `Foo.prototype`.
- `instanceof` is also a type guard, and TypeScript narrows in branches guarded by `instanceof`.

```javascript
function logValue(x: Date | string) {
  if (x instanceof Date) {
    // (parameter) x: Date
    console.log(x.toUTCString())
  } else {
    // (parameter) x: string
    console.log(x.toUpperCase())
  }
}
```

## Assignments

- Ts looks at the right side of the assignment and narrows the left side appropriately.

```javascript
// type is "let x: string | number"
let x = Math.random() < 0.5 ? 10 : 'hello world!'

// Narrowed to let x: number
x = 1

// Narrowed to let x: string
x = 'goodbye!'

// Error: Type 'boolean' is not assignable to
// type 'string | number'.
x = true
```

## Control flow analysis

- The analysis of code based on `reachability` is called `control flow analysis`, and TypeScript uses this flow analysis to narrow types as it encounters type guards and assignments

```javascript
function padLeft(padding: number | string, input: string) {
  if (typeof padding === 'number') {
    // If padding is number then this function
    // will return
    return ' '.repeat(padding) + input
  }
  // This code is not 'reachable' if padding
  // has number as one of it's types.
  // Ts analyzed and removed 'number' from
  // type of padding in this branch of code.
  return padding + input
}
```

## Using type predicates

- These are user-defined type guards, we simply need to define a function whose return type is a `type predicate`.
- `type predicate`: It takes the form `parameterName is Type`. Any time isFish is called with some variable, Ts will narrow that variable to that specific type if the original type is compatible.

```javascript
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}

// Both calls to 'swim' and 'fly' are now okay.
let pet = getSmallPet();

if (isFish(pet)) {
  // pet is a Fish
  pet.swim();
} else {
  // pet is not a Fish, only other
  // option is Bird type
  pet.fly();
}

// You may use the type guard isFish to filter an
// array of 'Fish | Bird' and obtain an 'array of Fish'
const zoo: (Fish | Bird)[] =
    [getSmallPet(), getSmallPet(), getSmallPet()];
const underWater1: Fish[] = zoo.filter(isFish);
// or, equivalently
const underWater2: Fish[] = zoo.filter(isFish) as Fish[];

// The predicate may need repeating for more complex examples
const underWater3: Fish[] = zoo.filter((pet): pet is Fish => {
  if (pet.name === "sharkey") return false;
  return isFish(pet);
});
```

## Discriminated unions

-

## The `never` type

- When narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, ts will use a `never` type to represent a state which shouldn’t exist.

#### function and function types.

- Return type of a function can be inferred.

## Syntax for function return type.

- Put Return type of void in functions, when don't return anything.

```javascript
Generics:
functionName<T>(){
}

const stringArray = insertAtBeginning<string>(['a', 'b', 'c'], 'd');
```

- So we can not just use the angle brackets to define a generic type but also to USE a generic type and explicitly set the placeholder type that should be used
- sometimes this is required if TypeScript is not able to infer the (correct) type. We'll see this later in this course section!

- npx create-react-app --template typescript

## React with ts.

`React.FC<{items: string []}>`

## Function type in ts:

```
()=>void

useState<>()
```

## ts and context API

`any` type: can hold any the, if a variable is not annotated, it is of type any.

[React component in TS](https://kentcdodds.com/blog/how-to-write-a-react-component-in-typescript)
[Fetch in TS](https://kentcdodds.com/blog/using-fetch-with-type-script)
[useState in TS](https://kentcdodds.com/blog/wrapping-react-use-state-with-type-script)
[Function overload in TS](https://kentcdodds.com/blog/define-function-overload-types-with-type-script)
